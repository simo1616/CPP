
# Plan de d√©part 

## 0) Pr√©pare l‚Äôinterface (d√©j√† fait)

* Classe non-instanciable (ctor/copy/assign/dtor priv√©s).
* M√©thode statique `convert(const std::string&)`.

## 1) √âcris un *petit* d√©tecteur de type (string only)

Fais une fonction interne (ex: `detectType(input) -> enum { CHAR_T, INT_T, FLOAT_T, DOUBLE_T, PSEUDO_FLOAT, PSEUDO_DOUBLE, INVALID }`).

Ordre de d√©tection recommand√© (du plus sp√©cifique au plus simple) :

1. **Pseudo-litt√©raux** (match exact, sensible √† la casse)

   * `PSEUDO_FLOAT` : `nanf`, `+inff`, `-inff`
   * `PSEUDO_DOUBLE` : `nan`, `+inf`, `-inf`
2. **Char**

   * Soit **forme canonique** : un caract√®re entre quotes simples, p.ex. `'a'` (longueur 3)
   * Soit tu acceptes **un unique caract√®re imprimable** sans quotes (ex: `a`). (Choisis une seule convention et sois coh√©rent.)
3. **Float**

   * **Il y a un point** `.`
   * **Termine par `f`**
   * Le reste : signe optionnel, **au moins un chiffre avant et apr√®s le point** (on reste en **notation d√©cimale** uniquement, le sujet l‚Äôimpose).
4. **Double**

   * **Il y a un point** `.`
   * **Ne** se termine **pas** par `f`
   * M√™me r√®gles de chiffres que pour float (au moins un avant et un apr√®s).
5. **Int**

   * Signe optionnel, puis **uniquement des chiffres**.
   * **Pas** de point, **pas** de `f`.

‚ö†Ô∏è D√©tails utiles pour la validation lexicale :

* Autorise un seul `+` ou `-` **au d√©but**.
* **Un seul** point pour float/double.
* Pour `int`, refuse `+`, `-` seuls sans chiffres.
* Pour `float`, exige le `f` **en fin de cha√Æne** (pas ailleurs).
* Pas d‚Äôespaces au d√©but/fin (le sujet n‚Äôen pr√©voit pas).

üí° Astuce mentale (r√®gles ‚Äúregex‚Äù que tu peux *imiter* sans forc√©ment √©crire une regex) :

* **int** : `^[+-]?[0-9]+$`
* **float** : `^[+-]?[0-9]+\.[0-9]+f$`
* **double** : `^[+-]?[0-9]+\.[0-9]+$`

## 2) Une fois le type d√©tect√©, d√©cide comment parser

* **C++98**: √©vite `std::stoi/std::stof/std::stod` (C++11).
  Utilise des √©quivalents *C* s√ªrs :

  * `int` ‚Üí `strtol`
  * `float`/`double` ‚Üí `strtod` puis cast en `float` si source = float
  * `char` ‚Üí lis directement le caract√®re
* **Pseudo-litt√©raux** : pas de parse num√©rique ‚Äúclassique‚Äù ; traite comme cas sp√©ciaux (tu ‚Äúsais‚Äù d√©j√† ce que tu devras afficher pour float/double, et ‚Äúimpossible‚Äù pour char/int).

## 3) Conversions vers les 4 types (r√®gles conceptuelles)

* **char**

  * Pseudos : **impossible**
  * Si hors plage (`< 0` ou `> 127` pour un `char` sign√© classique en 42) ‚Üí **impossible**
  * Si non affichable (`!isprint`) ‚Üí **Non displayable**
  * Sinon afficher `'c'`
* **int**

  * Pseudos : **impossible**
  * V√©rifie les bornes avant cast (`std::numeric_limits<int>::min()/max()`) ‚Üí sinon **impossible**
  * Sinon afficher la valeur enti√®re
* **float**

  * Pour un nombre ‚Äúnormal‚Äù, affiche avec **une d√©cimale** et le suffixe **`f`**.
    (p.ex. `42` ‚Üí `42.0f`)
  * Pour **`nan`/`¬±inf`** : affiche `nanf`, `+inff`, `-inff`
* **double**

  * Idem float mais **sans** `f` (`42.0`, `nan`, `+inf`, `-inf`)

üí° Pour imposer ‚Äúune d√©cimale‚Äù, tu utiliseras plus tard `std::fixed` + `std::setprecision(1)`.

## 4) Ordre d‚Äôimpl√©mentation conseill√© (micro-commits)

1. **Affiche juste l‚Äôinput** (tu l‚Äôas).
2. Impl√©mente **uniquement la d√©tection** (retourne l‚Äôenum, sans rien parser).

   * Teste 10‚Äì15 entr√©es et v√©rifie que le type d√©tect√© est correct (papier/console).
3. Branche **uniquement les pseudos** : si `PSEUDO_FLOAT`/`PSEUDO_DOUBLE`, affiche les 4 lignes ‚Äúconceptuelles‚Äù (char/int impossibles, float/double pseudo).
4. Impl√©mente le **parse** pour un type simple (commence par **int**), puis affiche les 4 conversions (avec les r√®gles).
5. Ajoute **double**, puis **float**, puis **char**.
6. Termine par les **d√©tails d‚Äôaffichage** (for√ßage `.0`, spacing, messages exacts).

## 5) Jeu de tests minimal (d√©tection puis conversion)

* **Char** : `'A'`, `'z'` (et un cas non-affichable si tu veux tester le message, mais le sujet dit que l‚Äôentr√©e n‚Äôen aura pas)
* **Int** : `0`, `-42`, `42`, `+7`
* **Float** : `0.0f`, `-4.2f`, `4.2f`, `+3.0f`
* **Double** : `0.0`, `-4.2`, `4.2`, `+3.0`
* **Pseudos float** : `nanf`, `+inff`, `-inff`
* **Pseudos double** : `nan`, `+inf`, `-inf`
* **Invalides** (doivent √™tre rejet√©s en d√©tection) : `.`, `f`, `--1`, `+`, `4.f`, `4.`, `.` , `4..2`, `4.2ff`, `42f`, `inf` (sans +/- c√¥t√© double selon ta spec), etc.

---

## Synth√®se

* **Oui**, ta strat√©gie est la bonne.
* **Commence** par le **d√©tecteur de type 100% string**, **puis** seulement tu feras le parse/casts/affichages.
* Avance **√©tape par √©tape** : d‚Äôabord pseudos, puis int, puis double, puis float, puis char (ou l‚Äôordre que tu pr√©f√®res), en validant √† chaque fois.

