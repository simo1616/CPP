
# C++ - Module 08

**Conteneurs templés, itérateurs, algorithmes**

## Résumé

Ce document contient les exercices du Module 08 des modules C++.

**Version : 10.0**

## Sommaire

I. Introduction
II. Règles générales
III. Règles spécifiques au module
IV. Instructions IA
V. Exercice 00 : Easy find
VI. Exercice 01 : Span
VII. Exercice 02 : Mutated abomination
VIII. Rendu et évaluation par les pairs

---

# Chapitre I

## Introduction

C++ est un langage de programmation généraliste créé par Bjarne Stroustrup comme une extension du langage C, ou « C with Classes » (source : Wikipedia).

L'objectif de ces modules est de vous introduire à la Programmation Orientée Objet.
Ceci sera le point de départ de votre parcours C++.

De nombreux langages sont recommandés pour apprendre l’OOP. Nous avons choisi C++ car il dérive de votre bon vieil ami C.
Comme il s’agit d’un langage complexe, et afin de rester simple, votre code devra respecter le standard **C++98**.

Nous savons que le C++ moderne est très différent sur de nombreux aspects. Si vous souhaitez devenir un expert du C++, ce sera à vous d’aller plus loin une fois le tronc commun de 42 terminé.

---

# Chapitre II

## Règles générales

### Compilation

* Compilez votre code avec `c++` et les flags :
  `-Wall -Wextra -Werror`
* Votre code doit compiler même si vous ajoutez le flag :
  `-std=c++98`

### Format et conventions de nommage

* Les dossiers d’exercices doivent être nommés : `ex00`, `ex01`, … , `exn`.
* Nommez vos fichiers, classes, fonctions et attributs comme exigé dans les consignes.
* Les noms de classe doivent être écrits en **UpperCamelCase**.
  Exemples :
  `ClassName.hpp`, `ClassName.cpp`, `ClassName.tpp`.
* Tous les messages affichés doivent se terminer par un retour à la ligne et être envoyés sur la sortie standard.

### Style

* Aucune norme de style C++ imposée (adieu Norminette).
* Un code illisible est un code non évaluable : faites simple et clair.

### Autorisé / Interdit

Vous ne programmez plus en C, mais en C++ :

**Autorisé :**

* Presque toute la bibliothèque standard C++.

**Interdit :**

* Toutes les bibliothèques externes : C++11 et dérivés, Boost, etc.
* Les fonctions suivantes : `*printf()`, `*alloc()`, `free()`.
  → Utiliser ces fonctions mène à **0**.
* Les mots-clés `using namespace <ns_name>` et `friend` (sauf mention contraire).
  → Leur utilisation entraîne **-42**.
* La STL est **autorisée uniquement dans les modules 08 et 09**.
  → Avant cela : **interdiction totale des containers et des algorithmes**.
  → Sinon : **-42**.

### Contraintes de conception

* Les fuites mémoires existent aussi en C++ : tout `new` doit avoir son `delete`.
* Du module 02 au 09, vos classes doivent respecter la **forme canonique (Orthodox Canonical Form)** sauf indication contraire.
* Toute implémentation placée dans un header (sauf templates) entraîne **0**.
* Chaque header doit être autonome → inclure ses dépendances.
* Protégez vos headers contre la double inclusion (include guards), sinon **0**.

### Lecture des sujets

* Vous pouvez ajouter des fichiers si nécessaire.
* Les exemples contiennent parfois des exigences non écrites explicitement.
* Lisez toujours le module en entier avant de commencer.
* Et surtout : **UTILISEZ VOTRE CERVEAU**.

---

# Chapitre III

## Règles spécifiques au module

Dans ce module, les exercices **peuvent** être résolus sans utiliser les containers ou algorithmes de la STL.

Mais justement :

### **L’objectif du Module 08 est d’utiliser la STL.**

Vous devez utiliser **les Containers** (`vector`, `list`, `map`, etc.) et **les Algorithms** (header `<algorithm>`) partout où cela est pertinent.

Vous serez **très mal noté** si vous ne les utilisez pas, même si votre code fonctionne parfaitement.

### Templates

Vous pouvez définir vos templates directement dans les headers, ou séparer la déclaration (header) et l’implémentation dans un fichier `.tpp`.

Les fichiers header sont obligatoires, les `.tpp` sont optionnels.



************************************************************************************************************************************************************


# Exercice 00 : Easy find

**Exercice : 00**
**Nom : Easy find**
**Dossier de rendu :** `ex00/`
**Fichiers à rendre :** `Makefile`, `main.cpp`, `easyfind.{h, hpp}`
**Fichier optionnel :** `easyfind.tpp`
**Fonctions interdites :** Aucune

---

Un premier exercice simple pour bien démarrer.

Écrivez une fonction template `easyfind` qui accepte un type **T**.
Elle prend deux paramètres :

* le premier est de type **T**
* le second est un **int**

En supposant que **T est un conteneur d’entiers**, cette fonction doit rechercher **la première occurrence** du second paramètre dans le premier.

Si aucune occurrence n’est trouvée, vous pouvez **soit lancer une exception**, soit **retourner une valeur d’erreur** de votre choix.
Si vous manquez d’inspiration, analysez comment se comportent les conteneurs standards.

Bien sûr, implémentez et rendez vos **propres tests** afin de vérifier que tout fonctionne comme prévu.

Vous **n’avez pas besoin** de gérer les conteneurs associatifs.



************************************************************************************************************************************************************


# Chapitre VI

## Exercice 01 : Span

**Exercice : 01**
**Dossier de rendu :** `ex01/`
**Fichiers à rendre :** `Makefile`, `main.cpp`, `Span.{h, hpp}`, `Span.cpp`
**Fonctions interdites :** Aucune

Développez une classe **Span** capable de stocker un nombre maximal de **N entiers**.
`N` est une variable de type `unsigned int` et sera le **seul paramètre passé au constructeur**.

Cette classe devra posséder une fonction membre `addNumber()` permettant d’ajouter un seul nombre dans le Span. Elle sera utilisée pour remplir la structure.
Toute tentative d’ajouter un nouvel élément alors que **N éléments sont déjà stockés** devra lancer une **exception**.

Ensuite, implémentez deux fonctions membres :

* `shortestSpan()`
* `longestSpan()`

Elles devront respectivement :

* trouver la **plus petite distance** entre deux nombres stockés,
* trouver la **plus grande distance**,
  puis la retourner.

S’il n’y a **aucun nombre stocké** ou **un seul**, il est impossible de calculer un span.
Dans ce cas, vous devez **lancer une exception**.

Bien sûr, vous écrirez vos propres tests, qui devront être **bien plus complets** que ceux ci-dessous.
Testez notamment votre classe **Span avec au moins 10 000 nombres** (et plus si possible).

---

### Exemple d'exécution

```cpp
int main()
{
    Span sp = Span(5);
    sp.addNumber(6);
    sp.addNumber(3);
    sp.addNumber(17);
    sp.addNumber(9);
    sp.addNumber(11);

    std::cout << sp.shortestSpan() << std::endl;
    std::cout << sp.longestSpan() << std::endl;
    return 0;
}
```

Sortie attendue :

```
$> ./ex01
2
14
$>
```

---

### Bonus obligatoire du sujet

Pour finir, il serait très pratique de remplir votre Span **en utilisant une plage d’itérateurs**.
Faire des milliers d’appels successifs à `addNumber()` est fastidieux.

Implémentez une fonction membre permettant **d’ajouter plusieurs nombres en un seul appel**, en lui passant une **range d’itérateurs**.

> Astuce : Inspirez-vous des Containers de la STL.
> Plusieurs fonctions membres acceptent une plage d’itérateurs pour insérer une séquence complète d’éléments.



************************************************************************************************************************************************************



# Chapitre VII

## Exercice 02 : Mutated abomination

**Exercice : 02**
**Dossier de rendu :** `ex02/`
**Fichiers à rendre :** `Makefile`, `main.cpp`, `MutantStack.{h, hpp}`
**Fichier optionnel :** `MutantStack.tpp`
**Fonctions interdites :** Aucune

Il est maintenant temps de passer à des choses plus sérieuses. Développons quelque chose d’un peu étrange.

Le conteneur `std::stack` est très pratique. Malheureusement, c’est l’un des seuls conteneurs de la STL qui **n’est pas itérable**. C’est vraiment dommage.

Mais pourquoi accepter cette limitation ? Surtout si nous pouvons nous permettre de « bricoler » la stack originale afin d’y ajouter des fonctionnalités manquantes.

Pour réparer cette injustice, vous devez rendre le conteneur `std::stack` **itérable**.

Écrivez une classe **MutantStack**.
Elle devra être implémentée **à partir de `std::stack`**.

Cette classe offrira **toutes les fonctions membres de `std::stack`**, ainsi qu’une fonctionnalité supplémentaire : **des itérateurs**.

Bien entendu, vous devrez écrire et rendre vos propres tests afin de vous assurer que tout fonctionne correctement.

---

### Exemple de test

```cpp
int main()
{
    MutantStack<int> mstack;
    mstack.push(5);
    mstack.push(17);

    std::cout << mstack.top() << std::endl;

    mstack.pop();

    std::cout << mstack.size() << std::endl;

    mstack.push(3);
    mstack.push(5);
    mstack.push(737);
    //[...]
    mstack.push(0);

    MutantStack<int>::iterator it = mstack.begin();
    MutantStack<int>::iterator ite = mstack.end();

    ++it;
    --it;

    while (it != ite)
    {
        std::cout << *it << std::endl;
        ++it;
    }

    std::stack<int> s(mstack);
    return 0;
}
```

---

### Comportement attendu

Si vous exécutez ce programme une première fois avec votre **MutantStack**, puis une seconde fois en remplaçant **MutantStack** par, par exemple, un `std::list`, les deux sorties devront être **identiques**.

Bien entendu, lorsque vous testez avec un autre conteneur, vous devrez adapter le code en conséquence (par exemple, `push()` peut devenir `push_back()`).


