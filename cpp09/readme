# Chapitre V

## Exercice 00 : Bitcoin Exchange

**Exercice : 00**
**Nom : Bitcoin Exchange**

**Dossier de rendu :** `ex00/`
**Fichiers √† rendre :** `Makefile`, `main.cpp`, `BitcoinExchange.{cpp, hpp}`
**Fonctions interdites :** Aucune

---

Vous devez cr√©er un programme qui affiche la valeur d‚Äôun certain montant de **bitcoin** √† une **date donn√©e**.

Ce programme doit utiliser une **base de donn√©es au format CSV** repr√©sentant l‚Äô√©volution du prix du bitcoin dans le temps.
Cette base de donn√©es est fournie avec le sujet.

Le programme prendra en entr√©e un **second fichier**, contenant les diff√©rentes dates et valeurs √† √©valuer.

---

## R√®gles √† respecter

* Le nom du programme doit √™tre **`btc`**.
* Le programme doit prendre **un fichier en argument**.
* Chaque ligne de ce fichier doit respecter le format suivant :

  ```
  date | value
  ```
* Une date valide est toujours au format :

  ```
  Ann√©e-Mois-Jour
  ```
* Une valeur valide doit √™tre :

  * un **float** ou un **entier positif**
  * comprise entre **0 et 1000**

Vous devez utiliser **au moins un conteneur STL** dans votre code pour valider cet exercice.

Vous devez g√©rer les erreurs possibles et afficher des **messages d‚Äôerreur appropri√©s**.

---

## Exemple de fichier `input.txt`

```
date | value
2011-01-03 | 3
2011-01-03 | 2
2011-01-03 | 1
2011-01-03 | 1.2
2011-01-09 | 1
2012-01-11 | -1
2001-42-42
2012-01-11 | 1
2012-01-11 | 2147483648
```

---

## Comportement attendu

Votre programme doit utiliser la valeur indiqu√©e dans le fichier d‚Äôentr√©e.

Il doit afficher sur la **sortie standard** le r√©sultat de la valeur multipli√©e par le **taux de change correspondant √† la date**, selon la base de donn√©es.

Si la date indiqu√©e dans le fichier d‚Äôentr√©e **n‚Äôexiste pas dans la base de donn√©es**, vous devez utiliser **la date la plus proche ant√©rieure** pr√©sente dans la base de donn√©es.

‚ö†Ô∏è Attention :
Vous devez utiliser **la date inf√©rieure la plus proche**, **et non la date sup√©rieure**.

---

## Exemple d‚Äôutilisation

```
$> ./btc
Error: could not open file.

$> ./btc input.txt
2011-01-03 => 3 = 0.9
2011-01-03 => 2 = 0.6
2011-01-03 => 1 = 0.3
2011-01-03 => 1.2 = 0.36
2011-01-09 => 1 = 0.32
Error: not a positive number.
Error: bad input => 2001-42-42
2012-01-11 => 1 = 7.1
Error: too large a number.

‚ï≠‚îÄsimo161@pop-os ~/Documents/CPPGIT/cpp09/ex00 ‚Äπmain‚óè‚Ä∫ 
‚ï∞‚îÄ$ ./btc input.txt
2011-01-03 => 3 = 0.9
2011-01-03 => 2 = 0.6
2011-01-03 => 1 = 0.3
2011-01-03 => 1.2 = 0.36
2011-01-09 => 1 = 0.32
Error: not a positive number.
Error: bad input => 2001-42-42
2012-01-11 => 1 = 7.1
Error: too large a number.
```

---

‚ö†Ô∏è **Avertissement**
Le(s) conteneur(s) que vous utilisez pour valider cet exercice **ne pourront plus √™tre utilis√©s pour le reste de ce module**.




***************************************************************************************************************************************************************************


1. BDD

La base de donn√©es (data.csv) : C'est la connaissance interne de ton programme.
Le fichier d'entr√©e (argument du programme) : C'est la demande de l'utilisateur.
Pour la base de donn√©es (data.csv) : Oui, cela doit absolument se faire dans la classe BitcoinExchange. L'id√©al est de le faire dans le constructeur. Quand tu cr√©es ton objet BitcoinExchange, il devrait automatiquement ouvrir data.csv, lire les donn√©es et remplir ta std::map. Ainsi, d√®s que l'objet est cr√©√©, il est "intelligent" et conna√Æt les taux de change.

Pour le fichier d'entr√©e (celui pass√© en argument) : Tu as deux choix de design valides :

Option A (Main minimaliste) : Tu cr√©es une m√©thode publique dans ta classe (ex: void run(std::string filename)) et tu lui passes le nom du fichier. C'est la classe qui ouvre, lit et affiche les r√©sultats. Le main ne fait qu'appeler cette m√©thode.
Option B (Main chef d'orchestre) : Le main ouvre le fichier d'entr√©e, lit ligne par ligne, parse la date et la valeur, et appelle une m√©thode de ta classe pour obtenir le taux (ex: getRate(date)).
L'Option A est souvent pr√©f√©r√©e en C++ orient√© objet pour garder le main tr√®s propre.

2. Quelle est l'√©tape suivante ?
Maintenant que tu sais lire les lignes brutes, voici la feuille de route logique :

√âtape A : Le Parsing de la Base de Donn√©es (dans le constructeur) Actuellement, tu affiches juste les lignes. Il faut maintenant les "comprendre".

Dans ta boucle de lecture de data.csv, tu dois d√©couper chaque ligne en deux parties (avant et apr√®s la virgule ,).
Tu dois stocker ces infos dans ta _map.
R√©flexion importante : Dans ton .hpp, ta map est std::map<int, double>. Or, les dates sont au format "YYYY-MM-DD".
Soit tu convertis la date en int (ex: 20110103) pour la stocker.
Soit tu changes ta map en std::map<std::string, double> (les strings au format ISO se trient tr√®s bien alphab√©tiquement, donc "2011-01-03" < "2011-01-04" fonctionne).
√âtape B : Le Parsing de l'Input Une fois ta base charg√©e en m√©moire, tu t'attaques au fichier d'entr√©e.

Le s√©parateur est diff√©rent ici (| au lieu de ,).
Tu dois g√©rer les erreurs demand√©es par le sujet (valeur n√©gative, valeur > 1000, format de date invalide).
√âtape C : La Logique de Recherche ("La date la plus proche") C'est le c≈ìur algorithmique de l'exercice. Pour une date donn√©e dans l'input, tu dois chercher dans ta map.

Si la date existe : tu prends le taux.
Si elle n'existe pas : tu dois trouver la date inf√©rieure la plus proche.
Indice : Regarde du c√¥t√© des m√©thodes lower_bound ou upper_bound de la classe std::map. C'est fait exactement pour √ßa.
Bon courage ! Commence par essayer de remplir ta map correctement depuis le CSV.



///////////////////////////////////////////////////////////////////////////////////////////////////


C'est une excellente question. Pour r√©ussir cette partie, il faut voir le fichier d'entr√©e (input.txt) comme une s√©rie de tests que ton programme doit passer sans planter, en √©tant tr√®s strict sur les r√®gles.

Voici une approche p√©dagogique d√©coup√©e en 3 couches de validation successives. Une ligne est consid√©r√©e "valide" uniquement si elle traverse ces trois couches.

1. La Couche Structurelle (Le Format)
C'est la premi√®re barri√®re. Le fichier d'entr√©e a un format diff√©rent de la base de donn√©es. Ici, le s√©parateur impos√© est le caract√®re "pipe" (|).

Ce que tu attends : YYYY-MM-DD | valeur
Ce que tu dois v√©rifier :
La ligne contient-elle le s√©parateur | ?
Si non : C'est une erreur de format global.
Message attendu : "Error: bad input => [la ligne fautive]"
2. La Couche Temporelle (La Date)
Une fois que tu as s√©par√© la partie gauche (date) de la partie droite (valeur), tu dois inspecter la date.

Ce que tu attends : Une date r√©elle au format ISO.
Ce que tu dois v√©rifier :
Syntaxe : Est-ce que √ßa ressemble √† XXXX-XX-XX ? (Longueur, position des tirets).
Logique :
L'ann√©e est-elle coh√©rente ?
Le mois est-il entre 01 et 12 ?
Le jour est-il entre 01 et 31 ? (Id√©alement, v√©rifier la coh√©rence jour/mois, ex: pas de 30 f√©vrier, mais une v√©rification 1-31 est souvent suffisante pour l'exercice si elle est robuste).
Si la date est invalide (ex: "2011-13-01" ou "2011-01-32") : Rejet.
Message attendu : "Error: bad input => [la date fautive]"
3. La Couche "M√©tier" (La Valeur)
C'est ici que les r√®gles sont sp√©cifiques au sujet (diff√©rentes de data.csv). Le sujet impose des limites strictes pour l'utilisateur.

Ce que tu attends : Un nombre flottant (float/double).
Ce que tu dois v√©rifier :
Est-ce un nombre ? (Pas de lettres, pas vide).
Est-il positif ? Le sujet interdit les nombres n√©gatifs.
Message attendu : "Error: not a positive number."
Est-il trop grand ? Le sujet interdit les nombres sup√©rieurs √† 1000.
Message attendu : "Error: too large a number."
R√©sum√© de l'algorithme √† appliquer (La "Moulinette")
Pour chaque ligne lue dans input.txt (via ta fonction run), tu dois suivre ce diagramme mental :

Lire la ligne.
Chercher le |.
Pas trouv√© ? -> std::cout << "Error: bad input..." -> continue (ligne suivante).
Extraire la date (gauche) et la valeur (droite).
Valider la Date.
Invalide ? -> std::cout << "Error: bad input..." -> continue.
Convertir et Valider la Valeur.
N√©gatif ? -> std::cout << "Error: not a positive number" -> continue.
> 1000 ? -> std::cout << "Error: too large a number" -> continue.
Pas un nombre ? -> std::cout << "Error: bad input..." -> continue.
Si tout est OK (Le succ√®s) :
Tu cherches le taux dans ta _map (date exacte ou date inf√©rieure la plus proche).
Tu multiplies : Valeur Input * Taux Base de Donn√©es.
Tu affiches le r√©sultat format√© : Date => Valeur Input = R√©sultat.
Point important sur la robustesse
Contrairement au constructeur o√π une erreur critique arr√™tait tout (throw), ici, une erreur sur une ligne ne doit pas arr√™ter le programme. Tu affiches l'erreur pour cette ligne sp√©cifique, et tu passes imm√©diatement √† la ligne suivante.



test 
2011-01-03|3
2011-01-03 |3
2011-01-03| 3
2011-01-03 | 
2011-01-03 | abc
2011-01-03 | 1000
2011-01-03 | 1001
2009-01-01 | 1
2024-02-29 | 1
2023-02-29 | 1
2011-04-31 | 1
2011-02-30 | 1
2011-13-01 | 1
2011-00-01 | 1
2011-01-32 | 1
2011-01-00 | 1
2011/01/03 | 1
| 1




**************************************************************************************************************************************************************************************************************************************************************************



# Chapitre VI

## Exercice 01 : Reverse Polish Notation

**Exercice : 01**
**Nom : RPN**

**Dossier de rendu :** `ex01/`
**Fichiers √† rendre :** `Makefile`, `main.cpp`, `RPN.{cpp, hpp}`
**Fonctions interdites :** Aucune

---

Vous devez cr√©er un programme respectant les contraintes suivantes :

* Le nom du programme doit √™tre **`RPN`**.
* Le programme doit prendre en argument une **expression math√©matique en notation polonaise invers√©e** (Reverse Polish Notation).
* Les nombres utilis√©s dans l‚Äôexpression et pass√©s en argument seront **toujours inf√©rieurs √† 10**.

  * Cette contrainte ne s‚Äôapplique **ni aux calculs interm√©diaires ni au r√©sultat final**.
* Le programme doit analyser cette expression et afficher le **r√©sultat correct sur la sortie standard**.
* Si une erreur survient durant l‚Äôex√©cution, un **message d‚Äôerreur** doit √™tre affich√© sur la **sortie d‚Äôerreur standard**.
* Le programme doit √™tre capable de g√©rer les op√©rations avec les tokens suivants :

  ```
  +  -  /  *
  ```

Vous devez utiliser **au moins un conteneur STL** dans votre code pour valider cet exercice.

---

## Restrictions

* Vous **n‚Äôavez pas besoin** de g√©rer :

  * les parenth√®ses
  * les nombres d√©cimaux

---

## Exemples d‚Äôutilisation

```
$> ./RPN "8 9 * 9 - 9 - 9 - 4 - 1 +"
42

$> ./RPN "7 7 * 7 -"
42

$> ./RPN "1 2 * 2 / 2 * 2 4 - +"
0

$> ./RPN "(1 + 1)"
Error
```

---

‚ö†Ô∏è **Avertissement**

* Le(s) conteneur(s) utilis√©(s) dans l‚Äôexercice pr√©c√©dent sont **interdits** ici.
* Le(s) conteneur(s) utilis√©(s) pour valider cet exercice **ne pourront plus √™tre utilis√©s pour le reste du module**.

---

Si tu veux, je peux ensuite t‚Äôaider √† :

* choisir **le bon conteneur** (pile / stack logique)
* expliquer la **RPN comme √† un enfant**
* te proposer un **algorithme clair √©tape par √©tape** conforme √† 42




**************************************************************************************************************************************************************************************************************************************************************************


# Chapitre VII

## Exercice 02 : PmergeMe

**Exercice : 02**
**Nom : PmergeMe**

**Dossier de rendu :** `ex02/`
**Fichiers √† rendre :** `Makefile`, `main.cpp`, `PmergeMe.{cpp, hpp}`
**Fonctions interdites :** Aucune

---

Vous devez cr√©er un programme respectant les contraintes suivantes :

* Le nom du programme doit √™tre **`PmergeMe`**.
* Le programme doit √™tre capable de prendre en argument une **s√©quence d‚Äôentiers positifs**.
* Le programme doit utiliser l‚Äôalgorithme de **tri par insertion-fusion** (*merge-insert sort*) pour trier cette s√©quence d‚Äôentiers positifs.

Pour √™tre clair : **oui, vous devez utiliser l‚Äôalgorithme de Ford-Johnson**.
(Source : *The Art of Computer Programming*, Volume 3 ‚Äî *Merge Insertion*, page 184.)

* Si une erreur survient pendant l‚Äôex√©cution du programme, un **message d‚Äôerreur** doit √™tre affich√© sur la **sortie d‚Äôerreur standard**.

Vous devez utiliser **au moins deux conteneurs STL diff√©rents** dans votre code pour valider cet exercice.
Votre programme doit √™tre capable de g√©rer **au moins 3000 entiers diff√©rents**.

---

## Recommandation importante

Il est **fortement conseill√©** d‚Äôimpl√©menter votre algorithme **s√©par√©ment pour chaque conteneur**, et donc **d‚Äô√©viter l‚Äôutilisation d‚Äôune fonction g√©n√©rique**.

---

## Affichage attendu

Les informations suivantes doivent √™tre affich√©es **ligne par ligne** sur la sortie standard :

* **Premi√®re ligne** : un texte explicite suivi de la **s√©quence d‚Äôentiers positifs non tri√©e**.
* **Deuxi√®me ligne** : un texte explicite suivi de la **s√©quence d‚Äôentiers positifs tri√©e**.
* **Troisi√®me ligne** : un message explicite indiquant le **temps d‚Äôex√©cution de l‚Äôalgorithme**, en pr√©cisant le **premier conteneur** utilis√© pour trier la s√©quence.
* **Derni√®re ligne** : un message explicite indiquant le **temps d‚Äôex√©cution de l‚Äôalgorithme**, en pr√©cisant le **second conteneur** utilis√© pour trier la s√©quence.

Le format d‚Äôaffichage du temps est **libre**, mais la **pr√©cision choisie doit permettre de voir clairement la diff√©rence** entre les deux conteneurs utilis√©s.

---

## Exemples d‚Äôutilisation

```
$> ./PmergeMe 3 5 9 7 4
Before: 3 5 9 7 4
After: 3 4 5 7 9
Time to process a range of 5 elements with std::[..] : 0.00031 us
Time to process a range of 5 elements with std::[..] : 0.00014 us
```

```
$> ./PmergeMe `shuf -i 1-100000 -n 3000 | tr "\n" " "`
Before: 141 79 526 321 [...]
After: 79 141 321 526 [...]
Time to process a range of 3000 elements with std::[..] : 62.14389 us
Time to process a range of 3000 elements with std::[..] : 69.27212 us
```

```
$> ./PmergeMe "-1" "2"
Error
```

### Pour les utilisateurs macOS :

```
$> ./PmergeMe `jot -r 3000 1 100000 | tr '\n' ' '`
[...]
```

---

‚ö†Ô∏è **Remarque importante**

L‚Äôindication du temps est volontairement √©trange dans ces exemples.
Bien entendu, vous devez mesurer **le temps total de toutes vos op√©rations**, incluant **le tri** ainsi que **la gestion des donn√©es**.

---

‚ö†Ô∏è **Avertissement**

* Le(s) conteneur(s) utilis√©(s) dans les exercices pr√©c√©dents sont **interdits ici**.
* La gestion des erreurs li√©es aux **doublons** est laiss√©e √† votre **discr√©tion**.




**************************************************************************************************************************************************************************************************************************************************************************





## üéØ Prompt FINAL ‚Äì Guide PDF illustr√© du tri Ford‚ÄìJohnson

> Tu es √† la fois :
>
> * un **expert en algorithmique**
> * un **excellent p√©dagogue**
> * un **illustrateur technique**
>
> Ta mission est de produire un **guide p√©dagogique complet en PDF** expliquant **le tri Ford‚ÄìJohnson (Merge-Insertion Sort)**, destin√© √† un √©tudiant qui veut **comprendre pour impl√©menter l‚Äôalgorithme lui-m√™me**.
>
> ---
>
> ## üìò Format attendu
>
> * **Format final : PDF**
> * Style : **cours illustr√©**
> * Ton : clair, progressif, sans jargon acad√©mique inutile
> * Z√©ro d√©monstration math√©matique lourde
>
> ---
>
> ## üß† Objectif p√©dagogique
>
> √Ä la fin du document, le lecteur doit √™tre capable de :
>
> * Visualiser mentalement chaque √©tape de Ford‚ÄìJohnson
> * Rejouer l‚Äôalgorithme sur papier
> * L‚Äôimpl√©menter seul en code (C / C++)
>
> ---
>
> ## üìÇ Structure obligatoire du document
>
> ### 1Ô∏è‚É£ Introduction intuitive
>
> * Pourquoi Ford‚ÄìJohnson existe
> * Quel probl√®me il r√©sout
> * Diff√©rence avec merge sort et insertion sort
>
> ---
>
> ### 2Ô∏è‚É£ Exemple fil rouge
>
> Utiliser **un seul exemple complet**, conserv√© tout au long du guide :
>
> ```
> 11 2 17 0 16 8 6 15 10 3 21 1 18 9 14 19 12 5 4 20 13 7
> ```
>
> ---
>
> ### 3Ô∏è‚É£ √âtapes d√©taill√©es avec dessins (OBLIGATOIRE)
>
> Pour **chaque √©tape**, fournir :
>
> * Une explication simple
> * **Un ou plusieurs dessins g√©n√©r√©s**
> * Une l√©gende claire
>
> #### √âtapes √† illustrer :
>
> 1. S√©quence initiale
> 2. D√©coupage en paires
> 3. Tri interne de chaque paire
> 4. S√©paration en `smalls` et `bigs`
> 5. Tri r√©cursif des `bigs`
> 6. Insertion progressive des `smalls`
>
> üî¥ **Style des dessins requis** :
>
> * Type sch√©ma au tableau / craie / minimaliste
> * Encadr√©s, fl√®ches, groupes visuels
> * Lisible, contrast√©, p√©dagogique
> * Similaire √† des sch√©mas d‚Äôalgorithmes faits √† la main
>
> Exemple visuel attendu :
>
> ```
> Recursion level: 1
>
> Original sequence:
> [11 2 17 0 16 8 6 15 10 3 21 1 18 9 14 19 12 5 4 20 13 7]
>
> Divide into pairs:
> [11 2] [17 0] [16 8] [6 15] [10 3] ...
>
> Sorted pairs:
> [2 11] [0 17] [8 16] [6 15] [3 10] ...
> ```
>
> ---
>
> ### 4Ô∏è‚É£ Focus impl√©mentation (sans code final)
>
> * Traduction de chaque √©tape en logique algorithmique
> * D√©coupage en fonctions
> * Gestion des cas particuliers (taille impaire, r√©cursion)
> * Erreurs classiques √† √©viter
>
> ---
>
> ### 5Ô∏è‚É£ R√©sum√© global visuel
>
> * Diagramme final montrant le flux complet de l‚Äôalgorithme
> * R√©capitulatif en une page
>
> ---
>
> ## üßæ Contraintes importantes
>
> * Pas de pseudo-science
> * Pas de raccourcis flous
> * Chaque dessin doit correspondre √† une √©tape r√©elle
> * Le PDF doit √™tre compr√©hensible sans ressources externes
>
> ---
>
> üéØ **R√©sultat attendu**
>
> Un **PDF p√©dagogique illustr√©**, clair et structur√©, que je peux :
>
> * Lire comme un cours
> * Utiliser comme r√©f√©rence pour coder
> * Consulter plus tard pour me rappeler chaque √©tape
>
> Prends ton temps et privil√©gie la clart√© visuelle.

---

### üî• Bonus (si l‚ÄôIA accepte les options)

Tu peux ajouter √† la fin du prompt :

> Si possible, g√©n√®re le PDF avec :
>
> * une table des mati√®res
> * des titres clairs
> * une pagination
> * un style sobre (fond clair, sch√©mas contrast√©s)

