# Chapitre V

## Exercice 00 : Bitcoin Exchange

**Exercice : 00**
**Nom : Bitcoin Exchange**

**Dossier de rendu :** `ex00/`
**Fichiers à rendre :** `Makefile`, `main.cpp`, `BitcoinExchange.{cpp, hpp}`
**Fonctions interdites :** Aucune

---

Vous devez créer un programme qui affiche la valeur d’un certain montant de **bitcoin** à une **date donnée**.

Ce programme doit utiliser une **base de données au format CSV** représentant l’évolution du prix du bitcoin dans le temps.
Cette base de données est fournie avec le sujet.

Le programme prendra en entrée un **second fichier**, contenant les différentes dates et valeurs à évaluer.

---

## Règles à respecter

* Le nom du programme doit être **`btc`**.
* Le programme doit prendre **un fichier en argument**.
* Chaque ligne de ce fichier doit respecter le format suivant :

  ```
  date | value
  ```
* Une date valide est toujours au format :

  ```
  Année-Mois-Jour
  ```
* Une valeur valide doit être :

  * un **float** ou un **entier positif**
  * comprise entre **0 et 1000**

Vous devez utiliser **au moins un conteneur STL** dans votre code pour valider cet exercice.

Vous devez gérer les erreurs possibles et afficher des **messages d’erreur appropriés**.

---

## Exemple de fichier `input.txt`

```
date | value
2011-01-03 | 3
2011-01-03 | 2
2011-01-03 | 1
2011-01-03 | 1.2
2011-01-09 | 1
2012-01-11 | -1
2001-42-42
2012-01-11 | 1
2012-01-11 | 2147483648
```

---

## Comportement attendu

Votre programme doit utiliser la valeur indiquée dans le fichier d’entrée.

Il doit afficher sur la **sortie standard** le résultat de la valeur multipliée par le **taux de change correspondant à la date**, selon la base de données.

Si la date indiquée dans le fichier d’entrée **n’existe pas dans la base de données**, vous devez utiliser **la date la plus proche antérieure** présente dans la base de données.

⚠️ Attention :
Vous devez utiliser **la date inférieure la plus proche**, **et non la date supérieure**.

---

## Exemple d’utilisation

```
$> ./btc
Error: could not open file.

$> ./btc input.txt
2011-01-03 => 3 = 0.9
2011-01-03 => 2 = 0.6
2011-01-03 => 1 = 0.3
2011-01-03 => 1.2 = 0.36
2011-01-09 => 1 = 0.32
Error: not a positive number.
Error: bad input => 2001-42-42
2012-01-11 => 1 = 7.1
Error: too large a number.

╭─simo161@pop-os ~/Documents/CPPGIT/cpp09/ex00 ‹main●› 
╰─$ ./btc input.txt
2011-01-03 => 3 = 0.9
2011-01-03 => 2 = 0.6
2011-01-03 => 1 = 0.3
2011-01-03 => 1.2 = 0.36
2011-01-09 => 1 = 0.32
Error: not a positive number.
Error: bad input => 2001-42-42
2012-01-11 => 1 = 7.1
Error: too large a number.
```

---

⚠️ **Avertissement**
Le(s) conteneur(s) que vous utilisez pour valider cet exercice **ne pourront plus être utilisés pour le reste de ce module**.




***************************************************************************************************************************************************************************


1. BDD

La base de données (data.csv) : C'est la connaissance interne de ton programme.
Le fichier d'entrée (argument du programme) : C'est la demande de l'utilisateur.
Pour la base de données (data.csv) : Oui, cela doit absolument se faire dans la classe BitcoinExchange. L'idéal est de le faire dans le constructeur. Quand tu crées ton objet BitcoinExchange, il devrait automatiquement ouvrir data.csv, lire les données et remplir ta std::map. Ainsi, dès que l'objet est créé, il est "intelligent" et connaît les taux de change.

Pour le fichier d'entrée (celui passé en argument) : Tu as deux choix de design valides :

Option A (Main minimaliste) : Tu crées une méthode publique dans ta classe (ex: void run(std::string filename)) et tu lui passes le nom du fichier. C'est la classe qui ouvre, lit et affiche les résultats. Le main ne fait qu'appeler cette méthode.
Option B (Main chef d'orchestre) : Le main ouvre le fichier d'entrée, lit ligne par ligne, parse la date et la valeur, et appelle une méthode de ta classe pour obtenir le taux (ex: getRate(date)).
L'Option A est souvent préférée en C++ orienté objet pour garder le main très propre.

2. Quelle est l'étape suivante ?
Maintenant que tu sais lire les lignes brutes, voici la feuille de route logique :

Étape A : Le Parsing de la Base de Données (dans le constructeur) Actuellement, tu affiches juste les lignes. Il faut maintenant les "comprendre".

Dans ta boucle de lecture de data.csv, tu dois découper chaque ligne en deux parties (avant et après la virgule ,).
Tu dois stocker ces infos dans ta _map.
Réflexion importante : Dans ton .hpp, ta map est std::map<int, double>. Or, les dates sont au format "YYYY-MM-DD".
Soit tu convertis la date en int (ex: 20110103) pour la stocker.
Soit tu changes ta map en std::map<std::string, double> (les strings au format ISO se trient très bien alphabétiquement, donc "2011-01-03" < "2011-01-04" fonctionne).
Étape B : Le Parsing de l'Input Une fois ta base chargée en mémoire, tu t'attaques au fichier d'entrée.

Le séparateur est différent ici (| au lieu de ,).
Tu dois gérer les erreurs demandées par le sujet (valeur négative, valeur > 1000, format de date invalide).
Étape C : La Logique de Recherche ("La date la plus proche") C'est le cœur algorithmique de l'exercice. Pour une date donnée dans l'input, tu dois chercher dans ta map.

Si la date existe : tu prends le taux.
Si elle n'existe pas : tu dois trouver la date inférieure la plus proche.
Indice : Regarde du côté des méthodes lower_bound ou upper_bound de la classe std::map. C'est fait exactement pour ça.
Bon courage ! Commence par essayer de remplir ta map correctement depuis le CSV.



///////////////////////////////////////////////////////////////////////////////////////////////////


C'est une excellente question. Pour réussir cette partie, il faut voir le fichier d'entrée (input.txt) comme une série de tests que ton programme doit passer sans planter, en étant très strict sur les règles.

Voici une approche pédagogique découpée en 3 couches de validation successives. Une ligne est considérée "valide" uniquement si elle traverse ces trois couches.

1. La Couche Structurelle (Le Format)
C'est la première barrière. Le fichier d'entrée a un format différent de la base de données. Ici, le séparateur imposé est le caractère "pipe" (|).

Ce que tu attends : YYYY-MM-DD | valeur
Ce que tu dois vérifier :
La ligne contient-elle le séparateur | ?
Si non : C'est une erreur de format global.
Message attendu : "Error: bad input => [la ligne fautive]"
2. La Couche Temporelle (La Date)
Une fois que tu as séparé la partie gauche (date) de la partie droite (valeur), tu dois inspecter la date.

Ce que tu attends : Une date réelle au format ISO.
Ce que tu dois vérifier :
Syntaxe : Est-ce que ça ressemble à XXXX-XX-XX ? (Longueur, position des tirets).
Logique :
L'année est-elle cohérente ?
Le mois est-il entre 01 et 12 ?
Le jour est-il entre 01 et 31 ? (Idéalement, vérifier la cohérence jour/mois, ex: pas de 30 février, mais une vérification 1-31 est souvent suffisante pour l'exercice si elle est robuste).
Si la date est invalide (ex: "2011-13-01" ou "2011-01-32") : Rejet.
Message attendu : "Error: bad input => [la date fautive]"
3. La Couche "Métier" (La Valeur)
C'est ici que les règles sont spécifiques au sujet (différentes de data.csv). Le sujet impose des limites strictes pour l'utilisateur.

Ce que tu attends : Un nombre flottant (float/double).
Ce que tu dois vérifier :
Est-ce un nombre ? (Pas de lettres, pas vide).
Est-il positif ? Le sujet interdit les nombres négatifs.
Message attendu : "Error: not a positive number."
Est-il trop grand ? Le sujet interdit les nombres supérieurs à 1000.
Message attendu : "Error: too large a number."
Résumé de l'algorithme à appliquer (La "Moulinette")
Pour chaque ligne lue dans input.txt (via ta fonction run), tu dois suivre ce diagramme mental :

Lire la ligne.
Chercher le |.
Pas trouvé ? -> std::cout << "Error: bad input..." -> continue (ligne suivante).
Extraire la date (gauche) et la valeur (droite).
Valider la Date.
Invalide ? -> std::cout << "Error: bad input..." -> continue.
Convertir et Valider la Valeur.
Négatif ? -> std::cout << "Error: not a positive number" -> continue.
> 1000 ? -> std::cout << "Error: too large a number" -> continue.
Pas un nombre ? -> std::cout << "Error: bad input..." -> continue.
Si tout est OK (Le succès) :
Tu cherches le taux dans ta _map (date exacte ou date inférieure la plus proche).
Tu multiplies : Valeur Input * Taux Base de Données.
Tu affiches le résultat formaté : Date => Valeur Input = Résultat.
Point important sur la robustesse
Contrairement au constructeur où une erreur critique arrêtait tout (throw), ici, une erreur sur une ligne ne doit pas arrêter le programme. Tu affiches l'erreur pour cette ligne spécifique, et tu passes immédiatement à la ligne suivante.



test 
2011-01-03|3
2011-01-03 |3
2011-01-03| 3
2011-01-03 | 
2011-01-03 | abc
2011-01-03 | 1000
2011-01-03 | 1001
2009-01-01 | 1
2024-02-29 | 1
2023-02-29 | 1
2011-04-31 | 1
2011-02-30 | 1
2011-13-01 | 1
2011-00-01 | 1
2011-01-32 | 1
2011-01-00 | 1
2011/01/03 | 1
| 1




**************************************************************************************************************************************************************************************************************************************************************************



# Chapitre VI

## Exercice 01 : Reverse Polish Notation

**Exercice : 01**
**Nom : RPN**

**Dossier de rendu :** `ex01/`
**Fichiers à rendre :** `Makefile`, `main.cpp`, `RPN.{cpp, hpp}`
**Fonctions interdites :** Aucune

---

Vous devez créer un programme respectant les contraintes suivantes :

* Le nom du programme doit être **`RPN`**.
* Le programme doit prendre en argument une **expression mathématique en notation polonaise inversée** (Reverse Polish Notation).
* Les nombres utilisés dans l’expression et passés en argument seront **toujours inférieurs à 10**.

  * Cette contrainte ne s’applique **ni aux calculs intermédiaires ni au résultat final**.
* Le programme doit analyser cette expression et afficher le **résultat correct sur la sortie standard**.
* Si une erreur survient durant l’exécution, un **message d’erreur** doit être affiché sur la **sortie d’erreur standard**.
* Le programme doit être capable de gérer les opérations avec les tokens suivants :

  ```
  +  -  /  *
  ```

Vous devez utiliser **au moins un conteneur STL** dans votre code pour valider cet exercice.

---

## Restrictions

* Vous **n’avez pas besoin** de gérer :

  * les parenthèses
  * les nombres décimaux

---

## Exemples d’utilisation

```
$> ./RPN "8 9 * 9 - 9 - 9 - 4 - 1 +"
42

$> ./RPN "7 7 * 7 -"
42

$> ./RPN "1 2 * 2 / 2 * 2 4 - +"
0

$> ./RPN "(1 + 1)"
Error
```

---

⚠️ **Avertissement**

* Le(s) conteneur(s) utilisé(s) dans l’exercice précédent sont **interdits** ici.
* Le(s) conteneur(s) utilisé(s) pour valider cet exercice **ne pourront plus être utilisés pour le reste du module**.

---

Si tu veux, je peux ensuite t’aider à :

* choisir **le bon conteneur** (pile / stack logique)
* expliquer la **RPN comme à un enfant**
* te proposer un **algorithme clair étape par étape** conforme à 42




**************************************************************************************************************************************************************************************************************************************************************************


# Chapitre VII

## Exercice 02 : PmergeMe

**Exercice : 02**
**Nom : PmergeMe**

**Dossier de rendu :** `ex02/`
**Fichiers à rendre :** `Makefile`, `main.cpp`, `PmergeMe.{cpp, hpp}`
**Fonctions interdites :** Aucune

---

Vous devez créer un programme respectant les contraintes suivantes :

* Le nom du programme doit être **`PmergeMe`**.
* Le programme doit être capable de prendre en argument une **séquence d’entiers positifs**.
* Le programme doit utiliser l’algorithme de **tri par insertion-fusion** (*merge-insert sort*) pour trier cette séquence d’entiers positifs.

Pour être clair : **oui, vous devez utiliser l’algorithme de Ford-Johnson**.
(Source : *The Art of Computer Programming*, Volume 3 — *Merge Insertion*, page 184.)

* Si une erreur survient pendant l’exécution du programme, un **message d’erreur** doit être affiché sur la **sortie d’erreur standard**.

Vous devez utiliser **au moins deux conteneurs STL différents** dans votre code pour valider cet exercice.
Votre programme doit être capable de gérer **au moins 3000 entiers différents**.

---

## Recommandation importante

Il est **fortement conseillé** d’implémenter votre algorithme **séparément pour chaque conteneur**, et donc **d’éviter l’utilisation d’une fonction générique**.

---

## Affichage attendu

Les informations suivantes doivent être affichées **ligne par ligne** sur la sortie standard :

* **Première ligne** : un texte explicite suivi de la **séquence d’entiers positifs non triée**.
* **Deuxième ligne** : un texte explicite suivi de la **séquence d’entiers positifs triée**.
* **Troisième ligne** : un message explicite indiquant le **temps d’exécution de l’algorithme**, en précisant le **premier conteneur** utilisé pour trier la séquence.
* **Dernière ligne** : un message explicite indiquant le **temps d’exécution de l’algorithme**, en précisant le **second conteneur** utilisé pour trier la séquence.

Le format d’affichage du temps est **libre**, mais la **précision choisie doit permettre de voir clairement la différence** entre les deux conteneurs utilisés.

---

## Exemples d’utilisation

```
$> ./PmergeMe 3 5 9 7 4
Before: 3 5 9 7 4
After: 3 4 5 7 9
Time to process a range of 5 elements with std::[..] : 0.00031 us
Time to process a range of 5 elements with std::[..] : 0.00014 us
```

```
$> ./PmergeMe `shuf -i 1-100000 -n 3000 | tr "\n" " "`
Before: 141 79 526 321 [...]
After: 79 141 321 526 [...]
Time to process a range of 3000 elements with std::[..] : 62.14389 us
Time to process a range of 3000 elements with std::[..] : 69.27212 us
```

```
$> ./PmergeMe "-1" "2"
Error
```

### Pour les utilisateurs macOS :

```
$> ./PmergeMe `jot -r 3000 1 100000 | tr '\n' ' '`
[...]
```

---

⚠️ **Remarque importante**

L’indication du temps est volontairement étrange dans ces exemples.
Bien entendu, vous devez mesurer **le temps total de toutes vos opérations**, incluant **le tri** ainsi que **la gestion des données**.

---

⚠️ **Avertissement**

* Le(s) conteneur(s) utilisé(s) dans les exercices précédents sont **interdits ici**.
* La gestion des erreurs liées aux **doublons** est laissée à votre **discrétion**.




**************************************************************************************************************************************************************************************************************************************************************************

