===== Array.hpp =====
#ifndef ARRAY_HPP
#define ARRAY_HPP


#include <iostream>
#include <exception>


template <typename T>
class Array {
	public:
		Array();
		Array(unsigned int size);
		Array(const Array& other); // Constructeur par copie
		Array& operator=(const Array& other); // Opérateur d'assignation
		T& operator[](unsigned int index);
		const T& operator[](unsigned int index) const;
		unsigned int size() const;
		~Array();

	private:
		T* _array;
		unsigned int _size;
};

#include "Array.tpp"

#endif
===== Array.tpp =====


template <typename T>
Array<T>::Array():_array(NULL), _size(0) {}

template <typename T>
Array<T>::Array(unsigned int size) : _array(new T[size]), _size(size) {}

template <typename T>
Array<T>::Array(const Array& other) : _array(NULL), _size(0) {
	*this = other;
}

template <typename T>
Array<T>& Array<T>::operator=(const Array& other) {
	if (this == &other)
		return *this;
	T* new_array = new T[other._size];
	for (unsigned int i = 0; i < other._size; i++) {
		new_array[i] = other._array[i];
	}
	delete[] _array;
	_array = new_array;
	_size = other._size;
	return *this;
}


template <typename T>
unsigned int Array<T>::size() const {return(_size);}

template <typename T>
T& Array<T>::operator[](unsigned int index) {
	if(index >= _size)
		throw std::out_of_range("Index is out of range");
	return(_array[index]);
}

template <typename T>
const T&  Array<T>::operator[](unsigned int index) const {
	if(index >= _size)
		throw std::out_of_range("Index is out of range");
	return(_array[index]);
}

template <typename T>
Array<T>::~Array() {
	delete[] this->_array;
}

===== main.cpp =====
#include "Array.hpp"

class X_ET_Y {
	public:
		X_ET_Y() : _x(0) {}
		X_ET_Y(int x, std::string str) : _x(x), _str(str) {}

		int getX() const { return _x; }
		const std::string& getStr() const { return _str; }

	private:
		int _x;
		std::string _str;
};

std::ostream& operator<<(std::ostream& os, const X_ET_Y& obj) {
	os << "X_ET_Y(x=" << obj.getX() << ", str='" << obj.getStr() << "')";
	return os;
}

int main () {
	unsigned int size = 5;
	Array<X_ET_Y> tablo(size);

	for(unsigned int i = 0; i < tablo.size(); i++){
		tablo[i] = X_ET_Y(i, "test");
	}

	const Array<X_ET_Y> tatab = tablo;

	for(unsigned int i = 0; i < tatab.size(); i++){
		std::cout << "tatab[" << i << "] = " << tatab[i] << std::endl;
	}

	std::cout << "\n--- Test d'affectation (Deep Copy) ---" << std::endl;
	Array<X_ET_Y> copyAssign;
	copyAssign = tablo; // Test explicite de l'opérateur =
	
	tablo[0] = X_ET_Y(999, "MODIFIED");
	std::cout << "Original modifié [0] : " << tablo[0] << std::endl;
	std::cout << "Copie (doit rester intacte) [0] : " << copyAssign[0] << std::endl;

	std::cout << "\n--- Test d'exception (Out of Range) ---" << std::endl;
	try {
		std::cout << "tentative d'accès à l'index invalide..." << std::endl;
		std::cout << tablo[500] << std::endl; // Doit lancer une exception
	} catch (const std::exception& e) {
		std::cerr << "exception catched : " << e.what() << std::endl;
	}

	std::cout << "\n--- Test tableau vide ---" << std::endl;
	Array<int> emptyArray;
	std::cout << "Taille tableau vide : " << emptyArray.size() << std::endl;
}
===== Makefile =====
NAME = array

CXX = c++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98
DBGFLAGS = -g -std=c++98

SRCS = main.cpp

OBJS = $(SRCS:.cpp=.o)

all: $(NAME)

$(NAME): $(OBJS)
		$(CXX) $(CXXFLAGS) $(OBJS) -o $(NAME)

clean:
		rm -f $(OBJS)

fclean: clean
		rm -f $(NAME)

re: fclean all

debug:
		$(CXX) $(DBGFLAGS) $(SRCS) -o $(NAME)

valgrind: debug
		valgrind ./$(NAME)

.PHONY: all clean fclean re

